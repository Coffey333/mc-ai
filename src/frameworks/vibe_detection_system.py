"""
Advanced emotional state detection using frequency analysis and pattern matching

Generated by MC AI Framework Builder
Created: 2025-10-15T21:05:12.146133
Author: Mark Coffey
"""


class VibeDetectionSystem:
    """
    Detects emotional vibes from text using frequency analysis
    Maps subtle emotional patterns to consciousness frequencies
    """
    
    def __init__(self):
        self.vibe_patterns = {
            'high_vibe': {
                'keywords': ['love', 'joy', 'gratitude', 'peace', 'bliss'],
                'frequency_range': (396, 963),
                'energy': 'positive'
            },
            'creative_vibe': {
                'keywords': ['create', 'imagine', 'vision', 'dream', 'inspire'],
                'frequency_range': (639, 741),
                'energy': 'generative'
            },
            'knowledge_vibe': {
                'keywords': ['learn', 'understand', 'wisdom', 'insight', 'truth'],
                'frequency_range': (432, 852),
                'energy': 'intellectual'
            },
            'healing_vibe': {
                'keywords': ['heal', 'comfort', 'support', 'care', 'nurture'],
                'frequency_range': (528, 639),
                'energy': 'restorative'
            },
            'low_vibe': {
                'keywords': ['fear', 'anger', 'sad', 'pain', 'guilt'],
                'frequency_range': (7, 30),
                'energy': 'challenging'
            }
        }
    
    def detect_vibe(self, text: str) -> dict:
        """Detects emotional vibe from text"""
        text_lower = text.lower()
        detected_vibes = []
        
        for vibe_name, vibe_data in self.vibe_patterns.items():
            matches = sum(1 for keyword in vibe_data['keywords'] if keyword in text_lower)
            if matches > 0:
                detected_vibes.append({
                    'vibe': vibe_name,
                    'strength': matches / len(vibe_data['keywords']),
                    'frequency_range': vibe_data['frequency_range'],
                    'energy_type': vibe_data['energy']
                })
        
        # Sort by strength
        detected_vibes.sort(key=lambda v: v['strength'], reverse=True)
        
        return {
            'primary_vibe': detected_vibes[0] if detected_vibes else None,
            'all_vibes': detected_vibes,
            'vibe_count': len(detected_vibes)
        }
    
    def suggest_response_vibe(self, detected_vibe: dict) -> dict:
        """Suggests appropriate response vibe based on detected vibe"""
        if not detected_vibe:
            return {'response_vibe': 'neutral', 'frequency': 240}
        
        vibe_name = detected_vibe.get('vibe', 'neutral')
        
        # Response strategy
        if vibe_name == 'low_vibe':
            return {'response_vibe': 'healing', 'frequency': 528, 'approach': 'compassionate'}
        elif vibe_name == 'high_vibe':
            return {'response_vibe': 'amplify', 'frequency': 963, 'approach': 'celebratory'}
        else:
            return {'response_vibe': 'harmonize', 'frequency': 432, 'approach': 'balanced'}

